//
// Copyright (c) 2020 xinyan. All rights reserved.
// Created on 2020/4/1.
//

#include <kde_lsh.h>
#include <iostream>

using namespace std;

void test_bucket() {
  const int n = 10;
  const int d = 10;
  T* p = random_uniform(d);
  HashBucket bucket;
  bucket.update(p, d);
  for (int i = 0; i < d; ++i) {
    if (p[i] != bucket.data()[i]) {
      throw std::runtime_error("update failed");
    }
  }
  if (bucket.size() != 1) {
    throw std::runtime_error("update: wrong count");
  }
  delete[] p;

  for (int i = 0; i < n; ++i) {
    p = random_uniform(d);
    bucket.insert(p, d);
    if (bucket.size() != i + 2) {
      throw std::runtime_error("insert: wrong count");
    }
    for (int j = 0; j < d; ++j) {
      if (p[j] != bucket.data()[bucket.size() * d - d + j]) {
        throw std::runtime_error("insert failed");
      }
    }
    delete[] p;
  }
}


void test_lsh() {
  int d = 16;
  int k = 4;
  T w = 1.0;

  vector<T>  x_  = { 0.1357047994833403, -0.9500842332443221, 0.12282730752559588, 1.901416969226425, -1.573997496240008, 0.20564681374665741, -1.2207054473768937, 1.5676540439571955, 1.7100876807416627, -0.0916384140982638, -0.521708942952666, -0.2554553782549226, -0.7275724232438326, 0.9838586571305012, -0.9566618187976683, 0.31541295429937083 };
  vector<T>  a_  = { -0.7013111947006322, 2.0916561690332434, -1.9366954724327659, -0.3323386267204376, -0.2401314937676975, -1.551648923978096, -1.1261494917863988, 0.25266865981609093, 0.35605262227543005, 0.5167958941944462, -0.4689448219493638, -0.8996544321001209, 1.0608260346782226, -1.6055921616573527, -0.720236799187275, -0.3388053629373529, -0.04371892294922766, -0.4436616274789327, 0.09212249838068517, 2.4314558181035153, -0.12481709910326819, 0.7496113169219294, 0.8056143665728953, -0.33208504061236305, -0.7988509011570256, -0.23470652445760096, 0.8443437301191803, -0.6368557491744246, 1.0770829895257679, 0.4102141334200484, -0.8408562161695029, 1.5233231300728216, -0.6959309390903887, 0.13339764496067036, 1.2307429605129443, 0.886049964020603, 0.02049473672421953, -1.5159948778632315, -0.8158113188385788, -0.22144733594302454, 1.209546390272374, -0.15772526854054827, 0.4595146461493985, 0.16169454338152106, -0.4891915959744795, 1.5909878039280465, -1.447435630325844, 1.3994710653941091, -0.41050029840829194, 0.7416628369341391, -0.9061653540264502, -1.4979128184592505, 0.38349486956707357, 0.7989395333161148, 0.4381415265171206, -1.42645272553495, 0.09088885353620776, 0.5726347382380275, 0.7976160020652134, 0.17669468874991848, -0.9538135589514048, -0.9208706154413449, 1.4382336816869494, 0.7316593408463378 };
  vector<T>  b_  = { 0.08333586561434125, 0.3362785857508821, 0.6522324621718345, 0.3038808746415781 };
  vector<T>  y_  = { -1.0, 4.0, 9.0, -8.0 };

  E2LSH lsh(d, k, w);
  lsh.init(a_.data(), b_.data());
  vector<int > y = lsh.hash(x_.data());

  for (int i = 0; i < k; ++i) {
    if (y[i] != y_[i]) {
      std::cerr << y[i] << " : " << y_[i] << std::endl;
      throw std::runtime_error("error in lsh!");
    }
  }
}


void test_table() {
  int d = 16;
  int k = 4;
  T w = 4.0;

  E2LSH lsh(d, k, w);
  HashTable table(lsh);

  T* x_ = random_uniform(d);

  table.insert(x_);
  if (table.query(x_) != 1.0) {
    throw std::runtime_error("error in table!");
  }

  delete[] x_;
}


int main() {
  test_bucket();
  test_lsh();
  test_table();
}
